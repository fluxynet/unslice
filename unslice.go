package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"

	"github.com/jinzhu/inflection"
)

var (
	errInvalidCommand = errors.New("invalid command")
)

const (
	cmdMap    = "Map"
	cmdReduce = "Reduce"
	cmdFilter = "Filter"

	header = "// Code generated by unslice. DO NOT EDIT."
)

const tplMap = `
//{{.Funcname}} performs concurrent transformation of a slice of {{.Input}} into a slice of {{.Output}}
func {{.Funcname}}({{.Data}} []{{.Input}}, fn func({{.Item}} {{.Input}}, {{.I}} {{.Index}}) {{.Output}}) []{{.Output}} {
	type result struct {
		index {{.Index}}
		value {{.Output}}
	}
	
	var wg sync.WaitGroup
	total   := len({{.Data}})
	results := make([]{{.Output}}, total)
	done    := make(chan result)
	wg.Add(total)
	
	go func(){
		for result := range done {
			results[result.index] = result.value
			wg.Done()
		}
	}()

	for {{.I}}, item := range {{.Data}} {
		go func({{.I}} {{.Index}}, item {{.Input}}) {
			done <- result{
				index: i,
				value: fn(i, item),
			}
		}({{.I}}, item)
	}

	wg.Wait()
	close(done)
	return results
}
`

const tplReduce = `
//{{.Funcname}} reduces a of a slice of {{.Input}} into a single {{.Output}}
func {{.Funcname}}({{.Data}} []{{.Input}}, fn func(prev {{.Output}}, {{.Item}} {{.Input}}, {{.I}} {{.Index}}) {{.Output}}) {{.Output}} {
	var output {{.Output}}
	for {{.I}} := range {{.Data}} {
		output = fn(output, {{.Data}}[{{.I}}], {{.I}})
	}

	return output
}
`

const tplFilter = `
//{{.Funcname}} concurrently removes items from a slice of {{.Input}} based on a filter function
//warning: indices may change and order will not be preserved
func {{.Funcname}}({{.Data}} []{{.Input}}, fn func({{.Item}} {{.Input}}, {{.I}} {{.Index}}) bool) []{{.Input}} {	
	var wg sync.WaitGroup
	var results []{{.Input}}
	done := make(chan {{.Input}})
	wg.Add(len({{.Data}}))
	
	go func(){
		for result := range done {
			results = append(results, result)
		}
	}()

	for {{.I}} := range {{.Data}} {
		go func({{.I}} {{.Index}}, item {{.Input}}) {
			if fn(item) {
				done <- item
			}
			wg.Done()
		}({{.I}}, {{.Data}}[i])
	}

	wg.Wait()
	close(done)
	return results
}
`

var (
	templateMap, templateReduce, templateFilter *template.Template
)

func init() {
	var err error

	templateMap, err = template.New("map").Parse(tplMap)
	if err != nil {
		log.Fatalln(err)
	}

	templateReduce, err = template.New("reduce").Parse(tplReduce)
	if err != nil {
		log.Fatalln(err)
	}

	templateFilter, err = template.New("filter").Parse(tplFilter)
	if err != nil {
		log.Fatalln(err)
	}
}

func ucfirst(str string) string {
	switch len(str) {
	case 0:
		return ""
	case 1:
		return strings.ToUpper(str)
	default:
		return strings.ToUpper(string(str[0])) + strings.ToLower(str[1:])
	}
}

//Map generator
func Map(input, output, index string) (string, error) {
	var (
		b bytes.Buffer
		i string
	)

	funcname := fmt.Sprintf("Map%sTo%s", inflection.Plural(ucfirst(input)), inflection.Plural(ucfirst(output)))
	item := strings.ToLower(input)
	data := inflection.Plural(item)

	if item == "i" {
		i = "x"
	} else {
		i = "i"
	}

	err := templateMap.Execute(&b, struct {
		Funcname string
		Input    string
		Output   string
		Data     string
		Item     string
		Index    string
		I        string
	}{funcname, input, output, data, item, index, i})

	if err == nil {
		return b.String(), nil
	}

	return "", err
}

//Reduce generator
func Reduce(input, output, index string) (string, error) {
	var (
		b bytes.Buffer
		i string
	)

	funcname := fmt.Sprintf("Reduce%sInto%s", inflection.Plural(ucfirst(input)), ucfirst(output))
	item := strings.ToLower(input)
	data := inflection.Plural(item)

	if item == "i" {
		i = "x"
	} else {
		i = "i"
	}

	err := templateReduce.Execute(&b, struct {
		Funcname string
		Input    string
		Output   string
		Data     string
		Item     string
		Index    string
		I        string
	}{funcname, input, output, data, item, index, i})

	if err == nil {
		return b.String(), nil
	}

	return "", err
}

//Filter generator
func Filter(input, index string) (string, error) {
	var (
		b bytes.Buffer
		i string
	)

	funcname := fmt.Sprintf("Filter%s", inflection.Plural(ucfirst(input)))
	item := strings.ToLower(input)
	data := inflection.Plural(item)

	if item == "i" {
		i = "x"
	} else {
		i = "i"
	}

	err := templateFilter.Execute(&b, struct {
		Funcname string
		Input    string
		Data     string
		Item     string
		Index    string
		I        string
	}{funcname, input, data, item, index, i})

	if err == nil {
		return b.String(), nil
	}

	return "", err
}

type cmd struct {
	fn     string
	input  string
	output string
	index  string
}

func (c cmd) String() string {
	return fmt.Sprintf(`fn="%s" index="%s" input="%s" output="%s"`, c.fn, c.index, c.input, c.output)
}

//parseArg checks the format and returns a command
//formats expected:
//	Map<string:Product>int
//	Map<Product>int
//	Reduce<Product>int
//	Reduce<string:Product>int
//	Filter<Product>
//	Filter<string:Product>
func parseArg(arg string) (cmd, error) {
	var re = regexp.MustCompile(`(?mi)^([a-z]+)<(([a-z]+):)?([a-z]+)>([a-z]+)?$`)
	var c cmd
	matches := re.FindStringSubmatch(arg)

	if matches == nil || len(matches) != 6 {
		return c, errInvalidCommand
	}

	c.fn = matches[1]
	c.index = matches[3]
	c.input = matches[4]
	c.output = matches[5]

	if c.index == "" {
		c.index = "int"
	}

	return c, nil
}

func help() {
	fmt.Println("Unslice is a golang code generator for collections.")
	fmt.Println("Usage:")
	fmt.Println(" -w Writes to disk")
	fmt.Println(" unslice mypackage Map<string:Product>int")
	fmt.Println(" unslice mypackage Map<Product>int")
	fmt.Println(" unslice mypackage Reduce<Product>int")
	fmt.Println(" unslice mypackage Reduce<string:Product>int")
	fmt.Println(" unslice mypackage Filter<Product>")
	fmt.Println(" unslice mypackage Filter<string:Product>")
	os.Exit(1)
}

func main() {
	var (
		code string
		pkg  string
		args []string
	)

	if len(os.Args) < 3 {
		help()
	}

	write := flag.Bool("w", false, "Write to file")
	flag.Parse()

	if *write {
		pkg = os.Args[2]
		args = os.Args[3:]
	} else {
		pkg = os.Args[1]
		args = os.Args[2:]
	}

	code = fmt.Sprintf("%s\npackage %s\n", header, pkg)
	for _, arg := range args {
		var s string
		c, err := parseArg(arg)
		if err != nil {
			fmt.Println("Error parsing argument: " + arg)
			help()
			os.Exit(1)
		}

		switch c.fn {
		default:
			help()
		case cmdMap:
			s, err = Map(c.input, c.output, c.index)
		case cmdReduce:
			s, err = Reduce(c.input, c.output, c.index)
		case cmdFilter:
			s, err = Filter(c.input, c.output)
		}

		if err != nil {
			log.Fatalln(err)
		}

		code += s
	}

	if *write {
		ioutil.WriteFile(pkg+"_unslice.go", []byte(code), 0755)
	} else {
		fmt.Println(code)
	}
}

